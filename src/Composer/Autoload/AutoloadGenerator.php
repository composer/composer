<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer\Autoload;

use Composer\Installer\InstallationManager;
use Composer\Json\JsonFile;
use Composer\Package\Loader\JsonLoader;
use Composer\Package\PackageInterface;
use Composer\Repository\RepositoryInterface;
use Composer\Downloader\Util\Filesystem;

/**
 * @author Igor Wiedler <igor@wiedler.ch>
 * @author Jordi Boggiano <j.boggiano@seld.be>
 */
class AutoloadGenerator
{
    public function dump(RepositoryInterface $localRepo, PackageInterface $mainPackage, InstallationManager $installationManager, $targetDir)
    {
        $autoloadFile = file_get_contents(__DIR__.'/ClassLoader.php');
        $autoloadFile .= <<<'EOF'

// autoload.php generated by Composer

function init() {
    $loader = new ClassLoader();

    $map = require __DIR__.'/autoload_namespaces.php';

    foreach ($map as $namespace => $path) {
        $loader->add($namespace, $path);
    }

    $loader->register();

    return $loader;
}

return init();
EOF;

        $filesystem = new Filesystem();
        $vendorPath = strtr(realpath($installationManager->getVendorPath()), '\\', '/');
        $relVendorPath = ltrim(substr($vendorPath, strlen(getcwd())), '/');
        $vendorDirCode = $filesystem->findShortestPathCode(realpath($targetDir), $vendorPath, true);

        $namespacesFile = <<<EOF
<?php

// autoload_namespace.php generated by Composer

\$vendorDir = $vendorDirCode;

return array(

EOF;

        // build package => install path map
        $packageMap = array();
        foreach ($localRepo->getPackages() as $installedPackage) {
            $packageMap[] = array(
                $installedPackage,
                $installationManager->getInstallPath($installedPackage)
            );
        }

        // add main package
        $packageMap[] = array($mainPackage, '');
        $autoloads = $this->parseAutoloads($packageMap);

        $appBaseDir = $filesystem->findShortestPathCode($vendorPath, getcwd(), true);
        $appBaseDir = str_replace('__DIR__', '$vendorDir', $appBaseDir);

        if (isset($autoloads['psr-0'])) {
            $exportedNamespaces = array();
            $exportedNamespacesMap = array();
            foreach ($autoloads['psr-0'] as $def) {
                $def['path'] = strtr($def['path'], '\\', '/');
                $baseDir = '';
                $isVendor = null;
                if (!$filesystem->isAbsolutePath($def['path'])) {
                    if (strpos($def['path'], $relVendorPath) === 0) {
                        $def['path'] = substr($def['path'], strlen($relVendorPath));
                        $baseDir = '$vendorDir . ';
                        $isVendor = true;
                    } else {
                        $def['path'] = '/'.$def['path'];
                        $baseDir = $appBaseDir . ' . ';
                        $isVendor = false;
                    }
                } elseif (strpos($def['path'], $vendorPath) === 0) {
                    $def['path'] = substr($def['path'], strlen($vendorPath));
                    $baseDir = '$vendorDir . ';
                    $isVendor = true;
                }
                $exportedPrefix = var_export($def['namespace'], true);
                $exportedPath = var_export($def['path'], true);
                if (!in_array($exportedPrefix, $exportedNamespaces)) {
                    $exportedNamespaces[] = $exportedPrefix;
                }
                if (!isset($exportedNamespacesMap[$exportedPrefix])) {
                    $exportedNamespacesMap[$exportedPrefix] = array();
                }
                $exportedNamespacesMap[$exportedPrefix][$isVendor?'vendor':'non-vendor'] = $baseDir.$exportedPath;
            }
            foreach ($exportedNamespaces as $exportedPrefix) {
                $pathMap = $exportedNamespacesMap[$exportedPrefix];
                $exportedPath = $pathMap[isset($pathMap['non-vendor'])?'non-vendor':'vendor'];
                $namespacesFile .= "    $exportedPrefix => $exportedPath,\n";
            }
        }

        $namespacesFile .= ");\n";

        file_put_contents($targetDir.'/autoload.php', $autoloadFile);
        file_put_contents($targetDir.'/autoload_namespaces.php', $namespacesFile);
    }

    /**
     * Compiles an ordered list of namespace => path mappings
     *
     * @param array $packageMap array of array(package, installDir-relative-to-composer.json)
     * @return array array('psr-0' => array(array('namespace' => 'Foo', 'path' => 'installDir')))
     */
    public function parseAutoloads(array $packageMap)
    {
        $autoloads = array();
        foreach ($packageMap as $item) {
            list($package, $installPath) = $item;

            if (null !== $package->getTargetDir()) {
                $installPath = substr($installPath, 0, -strlen('/'.$package->getTargetDir()));
            }

            foreach ($package->getAutoload() as $type => $mapping) {
                foreach ($mapping as $namespace => $path) {
                    $autoloads[$type][] = array(
                        'namespace' => $namespace,
                        'path'      => empty($installPath) ? $path : $installPath.'/'.$path,
                    );
                }
            }

        }

        foreach ($autoloads as $type => $maps) {
            usort($autoloads[$type], function ($a, $b) {
                return strcmp($b['namespace'], $a['namespace']);
            });
        }

        return $autoloads;
    }

    /**
     * Registers an autoloader based on an autoload map returned by parseAutoloads
     *
     * @param array $autoloads see parseAutoloads return value
     * @return ClassLoader
     */
    public function createLoader(array $autoloads)
    {
        $loader = new ClassLoader();

        if (isset($autoloads['psr-0'])) {
            foreach ($autoloads['psr-0'] as $def) {
                $loader->add($def['namespace'], $def['path']);
            }
        }

        return $loader;
    }
}
